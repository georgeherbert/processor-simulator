\documentclass{article}

\usepackage{float}

\title{Instruction Set Architecture}
\author{George Herbert}

\begin{document}
\maketitle

\abstract{This document outlines the instruction set architecture (ISA) of the processor simulator. The ISA is a subset of the RISC-V Unprivileged ISA, with several changes. Many of the sections in this document very closely correspond to the sections in `RISC-V Instruction Set Manual: Volume I: Unprivileged ISA'. While this is deliberate for ease of reference, it is not intended to imply that the ISA is identical.}

\section{RV32I Version 2.1}

\subsection{Registers}

For RV32I, the 32 \texttt{x} registers are each 32 bits wide (i.e. XLEN=32). Register \texttt{x0} is hardwired with all bits equal to 0. General purpose registers \texttt{x1}-\texttt{x31} hold values that various instructions interpret as a collection of Boolean values, or as two's complement signed binary integers or unsigned binary integers.

There is one additional unprivileged register: the program counter \texttt{pc} holds the address of the current instruction.

\subsection{Base Instruction Formats}

In the base RV32I ISA, there are four core instruction formats (R/I/S/U). All are a fixed 32 bits in length and must be aligned on a four-byte boundary in memory. Immediates are always sign-extended.

RISC-V base instruction formats, with corresponding numbers of bits for each field in brackets:
\begin{itemize}
    \item R-type: opcode (7), rd (5), funct3 (3), rs1 (5), rs2 (5), funct7 (7)
    \item I-type: opcode (7), rd (5), funct3 (3), rs1 (5), imm (12)
    \item S-type: opcode (7), funct3 (3), rs1 (5), rs2 (5), imm (12)
    \item U-type: opcode(7), rd(5), imm(20)
\end{itemize}

\subsection{Integer Computational Instructions}

Most integer computational instructions operate on XLEN bits of values held in the integer register file. Integer computational instructions are either encoded as register-immediate operations using the I-type format or as register-register operations using the R-type format.

\subsubsection{Integer Register-Immediate Instructions}

\begin{table}[H]
    \caption{Integer Register-Immediate Instructions}
    \begin{center}
    \setlength{\tabcolsep}{2pt}.
    \begin{tabular}{ccccccccccccccccccccccccccccccccc}
        \tiny{31}&\tiny{30}&\tiny{29}&\tiny{28}&\tiny{27}&\tiny{26}&\tiny{25}&\tiny{24}&\tiny{23}&\tiny{22}&\tiny{21}&\tiny{20}&\tiny{19}&\tiny{18}&\tiny{17}&\tiny{16}&\tiny{15}&\tiny{14}&\tiny{13}&\tiny{12}&\tiny{11}&\tiny{10}&\tiny{9}&\tiny{8}&\tiny{7}&\tiny{6}&\tiny{5}&\tiny{4}&\tiny{3}&\tiny{2}&\tiny{1}&\tiny{0}&
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{ADDI [\texttt{000}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{SLTI [\texttt{010}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{SLTIU [\texttt{011}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{ANDI [\texttt{111}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{ORI [\texttt{110}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{I-immediate} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{XORI [\texttt{100}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{shamt} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{SLLI [\texttt{001}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{shamt} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{SRLI [\texttt{101}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0100000} &
        \multicolumn{5}{|r|}{shamt} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{3}{|r|}{SRAI [\texttt{101}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP-IMM [\texttt{0010011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{20}{|r|}{U-immediate} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LUI [\texttt{0110111}]} &
        \ \tiny{U-type}
        \\
        \cline{1-32}
        \multicolumn{20}{|r|}{U-immediate} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{AUIPC [\texttt{0010111}]} &
        \ \tiny{U-type}
        \\
        \cline{1-32}
    \end{tabular}
    \end{center}
\end{table}

ADDI adds the sign-extended 12-bit immediate to register $rs1$. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.

SLTI (set less than immediate) places the value 1 in the register $rd$ if register $rs1$ is less than the sign-extended immediate when both are treated as signed numbers, else 0 is written to $rd$. SLTIU is similar, but compares the values as unsigned numbers (i.e. the immediate is first sign-extended to XLEN bits then treated as an unsigned number).

ANDI, ORI, XORI are logical operations that perform bitwise AND, OR and XOR on registers $rs1$ and the sign-extended 12-bit immediate and place the result in $rd$.

Shifts by a constant are encoded as a specialisation of the I-type format. The operand to be shifted is in $rs1$ and the shift amount is encoded in the lower 5 bits of the I-immediate field. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).

LUI (load upper immediate) is used to build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register $rd$, filling in the lowest 12 bits with zeros.

AUIPC (add upper immediate to \texttt{pc}) is used to build \texttt{pc}-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20th-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register $rd$.

\subsubsection{Integer Register-Register Operations}

RV32I defines several arithmetic R-type operations. All operations read the $rs1$ and $rs2$ registers as source operands and write the result into register $rd$. The $funct7$ and $funct3$ fields select the type of operation.

\begin{table}[H]
    \caption{Integer Register-Register Operations}
    \begin{center}
    \setlength{\tabcolsep}{2pt}.
    \begin{tabular}{ccccccccccccccccccccccccccccccccc}
        \tiny{31}&\tiny{30}&\tiny{29}&\tiny{28}&\tiny{27}&\tiny{26}&\tiny{25}&\tiny{24}&\tiny{23}&\tiny{22}&\tiny{21}&\tiny{20}&\tiny{19}&\tiny{18}&\tiny{17}&\tiny{16}&\tiny{15}&\tiny{14}&\tiny{13}&\tiny{12}&\tiny{11}&\tiny{10}&\tiny{9}&\tiny{8}&\tiny{7}&\tiny{6}&\tiny{5}&\tiny{4}&\tiny{3}&\tiny{2}&\tiny{1}&\tiny{0}&
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{ADD [\texttt{000}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SLT [\texttt{010}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SLTU [\texttt{011}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{AND [\texttt{111}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{OR [\texttt{110}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{XOR [\texttt{100}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SLL [\texttt{001}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0000000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SRL [\texttt{101}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0100000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SUB [\texttt{000}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
        \multicolumn{7}{|r|}{0100000} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{SRA [\texttt{101}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{OP [\texttt{0110011}]} &
        \ \tiny{R-type}
        \\
        \cline{1-32}
    \end{tabular}
    \end{center}
\end{table}

ADD performs the addition of $rs1$ and $rs2$. SUB performs the subtraction of $rs2$ from $rs1$. Overflows are ignored and the low XLEN bits of the results are written to the destination $rd$. SLT and SLTU perform signed and unsigned compares respectively, writing 1 to $rd$ if $rs1<rs2$, 0 otherwise. AND, OR and XOR perform bitwise logical operations.

SLL, SRL and SRA perform logical left, logical right and arithmetic right shifts on the value in register $rs1$ by the shift amount held in the lower 5 bits of register $rs2$.

\subsection{Control Transfer Instructions}

RV32I provides two types of control transfer instructions: unconditional jumps and conditional branches.

\subsubsection{Unconditional Jumps}

\begin{table}[H]
    \caption{Unconditional Jumps}
    \begin{center}
    \setlength{\tabcolsep}{2pt}.
    \begin{tabular}{ccccccccccccccccccccccccccccccccc}
        \tiny{31}&\tiny{30}&\tiny{29}&\tiny{28}&\tiny{27}&\tiny{26}&\tiny{25}&\tiny{24}&\tiny{23}&\tiny{22}&\tiny{21}&\tiny{20}&\tiny{19}&\tiny{18}&\tiny{17}&\tiny{16}&\tiny{15}&\tiny{14}&\tiny{13}&\tiny{12}&\tiny{11}&\tiny{10}&\tiny{9}&\tiny{8}&\tiny{7}&\tiny{6}&\tiny{5}&\tiny{4}&\tiny{3}&\tiny{2}&\tiny{1}&\tiny{0}&
        \\
        \cline{1-32}
        \multicolumn{20}{|r|}{offset} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{JAL [\texttt{1101111}]} &
        \ \tiny{U-type} 
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{000} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{JALR [\texttt{1100111}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
    \end{tabular}
    \end{center}
\end{table}

The jump and link (JAL) instruction uses the U-type format, where the U-immediate encodes a signed offset in multiples of 2 bytes. The offset is sign-extended and added to the address of the jump instruction to form the jump target address. Jumps can therefore target a $\pm 1$ MiB range. JAL stores the address of the instruction following the jump ($\texttt{pc}+4$) into register $rd$. The standard software calling convention uses \texttt{x1} as the return address register and $\texttt{x5}$ as an alternate link register.

The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the sign-extended 12-bit I-immediate to the register $rs1$, then setting the least-significant bit of the result to zero. The address of the instruction following the jump ($\texttt{pc} + 4$) is written to register $rd$.

\subsubsection{Conditional Branches}

\begin{table}[H]
    \caption{Conditional Branches}
    \begin{center}
    \setlength{\tabcolsep}{2pt}.
    \begin{tabular}{ccccccccccccccccccccccccccccccccc}
        \tiny{31}&\tiny{30}&\tiny{29}&\tiny{28}&\tiny{27}&\tiny{26}&\tiny{25}&\tiny{24}&\tiny{23}&\tiny{22}&\tiny{21}&\tiny{20}&\tiny{19}&\tiny{18}&\tiny{17}&\tiny{16}&\tiny{15}&\tiny{14}&\tiny{13}&\tiny{12}&\tiny{11}&\tiny{10}&\tiny{9}&\tiny{8}&\tiny{7}&\tiny{6}&\tiny{5}&\tiny{4}&\tiny{3}&\tiny{2}&\tiny{1}&\tiny{0}&
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BEQ [\texttt{000}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BNE [\texttt{001}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BLT [\texttt{100}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BLTU [\texttt{110}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BGE [\texttt{101}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src2} &
        \multicolumn{5}{|r|}{src1} &
        \multicolumn{3}{|r|}{BGEU [\texttt{111}]} &
        \multicolumn{7}{|r|}{BRANCH [\texttt{1100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
    \end{tabular}
    \end{center}
\end{table}

All branch instructions use the S-type instruction format. The 12-bit S-immediate encodes signed offsets in multiples of 2 bytes. The offset is sign-extended and added to the address of the branch instruction to give the target address. The conditional branch range is $\pm4$ KiB.

Branch instructions compare two registers. BEQ and BNE take the branch if registers $rs1$ and $rs2$ are equal or unequal respectively. BLT and BLTU take the branch if $rs1$ is less than $rs2$, using signed and unsigned comparison respectively. BGE and BGEU take the branch if $rs1$ is greater than or equal to $rs2$, using signed and unsigned comparison respectively. Note, BGT, BGTU, BLE and BLEU can be synthesised by reversing the operands to BLT, BLTU, BGE and BGEU, respectively.

\section{Load and Store Instructions}

\begin{table}[H]
    \caption{Load and Store Instructions}
    \begin{center}
    \setlength{\tabcolsep}{2pt}.
    \begin{tabular}{ccccccccccccccccccccccccccccccccc}
        \tiny{31}&\tiny{30}&\tiny{29}&\tiny{28}&\tiny{27}&\tiny{26}&\tiny{25}&\tiny{24}&\tiny{23}&\tiny{22}&\tiny{21}&\tiny{20}&\tiny{19}&\tiny{18}&\tiny{17}&\tiny{16}&\tiny{15}&\tiny{14}&\tiny{13}&\tiny{12}&\tiny{11}&\tiny{10}&\tiny{9}&\tiny{8}&\tiny{7}&\tiny{6}&\tiny{5}&\tiny{4}&\tiny{3}&\tiny{2}&\tiny{1}&\tiny{0}&
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{LW [\texttt{010}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LOAD [\texttt{0000011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{LH [\texttt{001}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LOAD [\texttt{0000011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{LHU [\texttt{101}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LOAD [\texttt{0000011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{LB [\texttt{000}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LOAD [\texttt{0000011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{LBU [\texttt{100}]} &
        \multicolumn{5}{|r|}{dest} &
        \multicolumn{7}{|r|}{LOAD [\texttt{0000011}]} &
        \ \tiny{I-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{SW [\texttt{010}]} &
        \multicolumn{7}{|r|}{STORE [\texttt{0100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{SH [\texttt{001}]} &
        \multicolumn{7}{|r|}{STORE [\texttt{0100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
        \multicolumn{12}{|r|}{offset} &
        \multicolumn{5}{|r|}{src} &
        \multicolumn{5}{|r|}{base} &
        \multicolumn{3}{|r|}{SB [\texttt{000}]} &
        \multicolumn{7}{|r|}{STORE [\texttt{0100011}]} &
        \ \tiny{S-type}
        \\
        \cline{1-32}
    \end{tabular}
    \end{center}
\end{table}

RV32I is a load-store architecture, where only load and store instructions access memory and arithmetic instructions only operate on CPU registers. RV32I provides a 32-bit address space that is byte-addressed.

Load and store instructions transfer a value between the registers and memory. Loads are encoded in the I-type format and stores are S-type. The effective address is obtained by adding registers $rs1$ to the sign-extended 12-bit offset. Loads copy a value from memory to register $rd$. Stores copy the value in register $rs2$ to memory.

The LW instruction loads a 32-bit value from memory into $rd$. LH loads a 16-bit value from memory, then sign-extends it to 32-bits before storing in $rd$. LHU loads a 16-bit value from memory but then zero extends it to 32-bits before storing in $rd$. LB and LBU are defined analogously for 8-bit values. The SW, SH and SB instructions store 32-bit, 16-bit and 8-bit values from the low bits of register $rs2$ to memory.

\end{document}